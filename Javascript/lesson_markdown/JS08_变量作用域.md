
# 变量作用域
	两个专业名词: "局部变量"与"全局变量"。
	变量作用域指的就是变量的作用范围，局部与全局起作用的范围是不一样的。

# A. 如何区分变量的作用域类型？
	1. 局部变量
		在函数内定义
	2. 全局变量
		在函数外定义

# B. 全局变量的特点
	1. 在函数外定义的都是全局变量
	2. 全局覆盖全局，任意地方都可以访问
	3. 有var与无var都一样，因为本身处于的位置(函数外部)就是全局的，推荐使用var。

# C. 局部变量
	1. 有关键字 var 声明
		在函数内部，使用关键字 var 声明的变量，就是局部变量，只能在函数中使用，作用域在整个函数内，外部不可访问。

	2. 无关键字 var 声明
		在函数内部，如果没有使用关键字 var 声明的变量，就是全局变量，外部可以访问

# D. 思考
	问题:
		函数外部与函数内部都有一个同名变量user，它们是否同一个变量？

# E. 全局变量的风险

# F. 提前声明
	* 局部变量有效范围是整个函数
	* JS的函数作用域是指在函数内声明的所有变量，在函数体内始终是可见的。这意味着变量在声明之前甚至已经可用。

# G. 函数声明提前
	1. 函数定义与调用不分先后，但是必须在同一个script标签

	2. js在解析阶段函数声明会被提升到最前面

# H. 变量作用域链

	* 函数定义是可以嵌套的，由于每个函数都有它自己的作用域。

	* 当JS需要查找变量xm的时候(这个过程叫做变量解析,variable resolution)。

	当JS需要查找变量xm的时候(这个过程叫做变量解析,variable resolution)，JS会从当前作用域开始查找，如果当前作用域有名字为 xm 的变量，则直接使用该值，如果不存在，则查找上一个作用域，以此类推，如果都没有，JS则认为该变量不存在，于是抛出一个引用错误(ReferenceError)异常。

	* Summary:
		1. 每个函数都有自己的作用域(每个函数就像房间一样)
		2. js是沿着作用域链，一级一级地搜索
		3. 只能向上寻找，不能向下寻找

# I. 子函数
	* 以后我们都是协作开发，不再是单独战斗，当项目庞大起来，命名就是一个比较严峻的问题。
	* 由于函数是可以被覆盖的，当代码合并时，命名就有可能冲突。过多使用全局变量，就有可能由于命名冲突而产生N多的 bug。(形成封闭环境，减少全局变量)
	* 如 x 命名的函数名为: foo() ，y 写的函数同样命名为 foo()


	* Summary:
		1. 函数中还能再定义函数
		2. 作用范围在当前函数内
		3. 这种模式让大家了解即可，JS在专门制定了与这种模型类似的语法。

# J. 自调用的函数
	1. 大家知道，过多使用全局变量，会污染全局，到时一些命名冲突。
	2. 自调用函数最大的好处就是可以模拟"命名空间"技术，命名空间，就是为了解决命名冲突而使用的！

	3. 在函数中声明的变量在整个函数体内都是可见的，在函数外部是不可见的。
	4. 当代码放在不同的执行环境中，我们无法得知这个变量是否已经创建了，如果已经存在这个变量，或者无意中修改了原有的值，那么将会和代码发生冲突。(与刚刚子函数提出的一致)
	5. 通过子函数，虽然已经减少了大量的全局变量，但这样还是麻烦，不够彻底。

	* 解决：形成一个封闭的环境，解决全局变量的污染!

# K. 闭包函数
	描述：
		闭包是JS的强大特性之一，而闭包函数总会在不经意之间形成。
		当一个函数中，使用了非本身作用域的变量，即可形成闭包。

	好处：
		希望一个变量长期驻扎在内存当中
		避免全局变量的污染

# 重点总结：
	1. 变量有两种，全局与局部
	2. 全局变量：
		1. 在函数外定义
		2. 在函数内，没有使用 var 定义
		3. 全局可以访问
	3. 局部变量的定义:
		1. 在函数内使用var定义的变量
		2. 作用范围在当前函数
	4. 变量作用域链
		只能向上,不能向下
		JS寻找一个变量，是沿着作用域链，一级一级向上寻找
	5. 全局变量有风险，使用需谨慎
	6. 提前声明
		函数中，无论在什么位置，只要使用var声明的局部变量，作用范围是整个函数，等价于在函数的第一行定义了该变量






<!--  -->
